在 transaction 定義中，有兩點值得引起注意：一是 **`my_transaction`** 的基類是 **`uvm_sequence_item`**。在 UVM 中，所有的 transaction 都要從 **`uvm_sequence_item`** 派生，只有從 **`uvm_sequence_item`** 派生的 transaction 才可以使用後文講述的 UVM 中強大的 sequence 機制。二是這裡沒有使用 **`uvm_component_utils`** 宏來實現 factory 機制，而是使用了 **`uvm_object_utils`**。從本質上來說，**`my_transaction`** 與 **`my_driver`** 是有區別的，在整個仿真期間，**`my_driver`** 是一直存在的，**`my_transaction`** 不同，它有生命周期。它在仿真的某一時間產生，經過 driver 驅動，再經過 reference model 處理，最終由 scoreboard 比較完成後，其生命周期就結束了。一般來說，這種類都是派生自 **`uvm_object`** 或者 **`uvm_object`** 的派生類，**`uvm_sequence_item`** 的祖先就是 **`uvm_object`**。UVM 中具有這種特徵的類都要使用 **`uvm_object_utils`** 宏來實現。當完成 transaction 的定義後，就可以在 **`my_driver`** 中實現基於 transaction 的驅動。

在 **`main_phase`** 中，首先使用 **`randomize`** 將 **`tr`** 隨機化，之後通過 **`drive_one_pkt`** 任務將 **`tr`** 的內容驅動到 DUT 的端口上。在 **`drive_one_pkt`** 中，先將 **`tr`** 中所有的數據壓入隊列 **`data_q`** 中，之後再將 **`data_q`** 中所有的數據彈出並驅動。將 **`tr`** 中的數據壓入隊列 **`data_q`** 中的過程相當於打包成一個 byte 流的過程。這個過程還可以使用 SystemVerilog 提供的流操作符實現。具體請參照 SystemVerilog 語言標準 IEEE Std 1800 TM—2012（IEEE Standard for SystemVerilog—Unified Hardware Design，Specification，and Verification Language）的 11.4.14 節。

<img width="781" alt="Transaction" src="https://github.com/ax0080/UVM/assets/78300584/aa8d380c-a505-44ed-98b6-8308c964f078">
